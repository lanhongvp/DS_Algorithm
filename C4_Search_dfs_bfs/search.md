# 深度优先搜索（DFS）
- 深度优先搜索是一种枚举所有完整路径以遍历所有情况的搜索方法
- 使用**递归**可以实现深度优先搜索
- C/C++使用递归时，系统会调用一个系统栈的东西存放递归中每一层的状态，因此使用递归来实现DFS的本质还是栈
## 迷宫问题
## 背包问题
- 有n件物品，每件物品重量为w[i]，价值为c[i]。现需要选出若干件物品放入一个容量为V的背包中，使得在选入背包的物品重量和不超过容量V的前提下，让背包中物品价值之和最大，求最大价值。（1<=n<=20）
    - 背包问题中的DFS解法其实是一种纯暴力搜索，即给出背包问题的所有解法，抽象对应成**岔道口
    - 采用递归的方式求解，其对应的**递归边界即死胡同**是所选物品件数已达n件；**递归式对应岔道口**是选择将物品放入背包或不放入背包
### 题9 DFS之图遍历问题
* 运用DFS的思想，遍历图中的每个结点
* 图的构造方式
  * 邻接矩阵，采用二维数组即可
  * 邻接表，采用vector进行构造
### 题9 注意点
* 运用深度优先搜索，最便捷的方式即采用递归的方式进行代码的编写
  * 注意：**若题中所给的图即为一个连通子图，一次DFS调用即可实现对于图的遍历；但若题中所给的图是多个连通子图，需要多次外部调用DFS，保证所有结点的遍历**
* **DFS伪码描述**
```
void dfs(int node){
  vis[node] = 1;    //表明该结点已被访问过，初始为0
  for(图中的所有结点){
    int tmp_node;  //图中的下一个待访问结点
    if(待访问结点没有被访问 && 现结点和待访问结点存在边){
      dfs(tmp_node);
    }
  }
}
```
### 题10 DFS暴力搜索背包问题【TODO 动态规划解法】
* 有n件物品，每件物品重量为w[i]，价值为c[i]。现需要选出若干件物品放入一个容量为V的背包中，使得在选入背包的物品重量和不超过容量V的前提下，让背包中物品价值之和最大，求最大价值。（1<=n<=20）
### 题10 注意点
* 背包问题中的DFS解法其实是一种纯暴力搜索，即给出背包问题的所有解法，抽象对应成**死胡同和岔道口**
* 采用递归的方式求解，其对应的**递归边界即死胡同**是所选物品件数已达n件；**递归式对应岔道口**是选择将物品放入背包或不放入背包

## 序列和问题
# 广度优先搜索（BFS）
## 迷宫问题
### 题11 BFS搜索之统计矩阵块数
* 给定一个m*n的矩阵，矩阵中的元素为0或1。称位置(x,y)与其上下左右四个位置是相邻的。如果矩阵中有若干个1是相邻的（不必两两相邻），那么称这些1构成一个块。求给定的矩阵中”块“的个数
### 题11 注意点
* 解题思路
  * 初始化矩阵，即类似于构造图的邻接矩阵
  * 采用BFS，若遇到矩阵中的0，跳过；若遇到矩阵中的1，BFS遍历四周，同理，若为0，跳过，若为1，继续BFS遍历
* BFS伪码描述
```
void bfs(int node){
  queue<int> q;  //存储邻接点的队列
  q.push(node);
  while(!q.empty()){
    int top_node = q.front();  //取出队首元素
    q.pop();                  //删除队首元素
    for(top_node的所有邻接点){   //访问队首元素的所有邻接点
      int tmp_node;    //top_node的邻接点
      if(tmp_node没有被访问){
        vis[tmp_node] = 1;   //将tmp_node设置成已被访问
        q.push(tmp_node);   //邻接点入队，便于下一层访问
      }
    }   
  }
}
```
* 关于BFS
  * vis[maxsize]数组的点亮位置：若在队列弹出时点亮此结点，即数组相应位置为1，有什么影响
