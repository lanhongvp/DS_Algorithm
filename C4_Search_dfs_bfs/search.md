# 深度优先搜索（DFS）
- 深度优先搜索是一种枚举所有完整路径以遍历所有情况的搜索方法
- 使用**递归**可以实现深度优先搜索
- C/C++使用递归时，系统会调用一个系统栈的东西存放递归中每一层的状态，因此使用递归来实现DFS的本质还是栈
## 迷宫问题
## 背包问题
- 有n件物品，每件物品重量为w[i]，价值为c[i]。现需要选出若干件物品放入一个容量为V的背包中，使得在选入背包的物品重量和不超过容量V的前提下，让背包中物品价值之和最大，求最大价值。（1<=n<=20）
    - 背包问题中的DFS解法其实是一种纯暴力搜索，即给出背包问题的所有解法，抽象对应成**岔道口
    - 采用递归的方式求解，其对应的**递归边界即死胡同**是所选物品件数已达n件；**递归式对应岔道口**是选择将物品放入背包或不放入背包
### 题9 DFS之图遍历问题
* 运用DFS的思想，遍历图中的每个结点
* 图的构造方式
  * 邻接矩阵，采用二维数组即可
  * 邻接表，采用vector进行构造
### 题9 注意点
* 运用深度优先搜索，最便捷的方式即采用递归的方式进行代码的编写
  * 注意：**若题中所给的图即为一个连通子图，一次DFS调用即可实现对于图的遍历；但若题中所给的图是多个连通子图，需要多次外部调用DFS，保证所有结点的遍历**
* **DFS伪码描述**
```
void dfs(int node){
  vis[node] = 1;    //表明该结点已被访问过，初始为0
  for(图中的所有结点){
    int tmp_node;  //图中的下一个待访问结点
    if(待访问结点没有被访问 && 现结点和待访问结点存在边){
      dfs(tmp_node);
    }
  }
}
```
### 题10 DFS暴力搜索背包问题【TODO 动态规划解法】
* 有n件物品，每件物品重量为w[i]，价值为c[i]。现需要选出若干件物品放入一个容量为V的背包中，使得在选入背包的物品重量和不超过容量V的前提下，让背包中物品价值之和最大，求最大价值。（1<=n<=20）
### 题10 注意点
* 背包问题中的DFS解法其实是一种纯暴力搜索，即给出背包问题的所有解法，抽象对应成**死胡同和岔道口**
* 采用递归的方式求解，其对应的**递归边界即死胡同**是所选物品件数已达n件；**递归式对应岔道口**是选择将物品放入背包或不放入背包

## 序列和问题
# 广度优先搜索（BFS）
## 迷宫问题
### 题11 BFS搜索之统计矩阵块数
* 给定一个m*n的矩阵，矩阵中的元素为0或1。称位置(x,y)与其上下左右四个位置是相邻的。如果矩阵中有若干个1是相邻的（不必两两相邻），那么称这些1构成一个块。求给定的矩阵中”块“的个数
### 题11 注意点
* 解题思路
  * 初始化矩阵，即类似于构造图的邻接矩阵
  * 采用BFS，若遇到矩阵中的0，跳过；若遇到矩阵中的1，BFS遍历四周，同理，若为0，跳过，若为1，继续BFS遍历
* BFS伪码描述
```
void bfs(int node){
  queue<int> q;  //存储邻接点的队列
  q.push(node);
  while(!q.empty()){
    int top_node = q.front();  //取出队首元素
    q.pop();                  //删除队首元素
    for(top_node的所有邻接点){   //访问队首元素的所有邻接点
      int tmp_node;    //top_node的邻接点
      if(tmp_node没有被访问){
        vis[tmp_node] = 1;   //将tmp_node设置成已被访问
        q.push(tmp_node);   //邻接点入队，便于下一层访问
      }
    }   
  }
}
```
* 关于BFS
  * vis[maxsize]数组的点亮位置：若在队列弹出时点亮此结点，即数组相应位置为1，有什么影响
### LC_39 组合总和问题
- DFS
- 死胡同和岔道口
  - 选择和不选择这个数
  - 返回条件
### LC_40 组合2
- DFS
- 注意先对数组进行排序
  - 重复元素的处理
### LC_77 组合数问题
- 边界条件的考虑
- 根据深度优先的思路去写
  - 有无重复元素
  - 递归层数的思考
### LC_78 子集
- 所给的序列中不存在重复元素
- DFS
  - 递归的时候注意层数
  - 分析递归的时候，注意变量所处范围的影响，函数内的局部变量以及for循环内的局部变量在递归调用时的区别
### LC_90 子集2
- 存在重复元素
  - 处理方式：递归调用时候选取的条件
  - 对比**LC_40**，类似的处理方式
```cpp
if((nums[i]==nums[i-1])&&(i>idx))
    continue;
```
### LC_104 二叉树的最大深度
- 二叉树的左右子树的处理
- 返回值的处理
### LC_111 二叉树的最小深度
- 对比二叉树的最大深度
- 理解递归何时进行返回，函数压栈的处理
- 递归的层数理解
### LC_130 包围的区域
- DFS和BFS均可
- 本题采用了DFS
  - 注意：逆向思考，首先寻找在边界上的'O'的点以及与之相邻的'O'点，对其进行处理
### LC_200 岛屿计数
- DFS和BFS均可
- 若用BFS，注意结构体的定义
### LC_207 课程表
- 拓扑排序问题
### LC_216 组合问题
- dfs问题
- 死胡同和岔道口
### LC_392 最长路径问题
- dfs
- 注意点
  - 递归调用的深度变量保留的处理
  - 最大值的处理
### LC_690 员工的重要性
- BFS即可
