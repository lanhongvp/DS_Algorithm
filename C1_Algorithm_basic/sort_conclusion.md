# 排序与查找
## 冒泡排序
- 冒泡排序的本质在于交换，即每次通过交换的方式把当前剩余元素的最大值移动到一端，而当剩余元素减少为0时，排序结束

## 简单选择排序
- 对一个序列A中的元素A[0]~A[n-1]，令i从0~(n-1)枚举，进行n趟操作，每趟从待排序部分[i,n-1]中选择最小的元素，令其与待排序部分的第一个元素A[i]进行交换，这样元素A[i]就会与当前有序区间[0,i-1]形成新的有序区间[0,i]

## 直接插入排序
- 对一个序列A的前i-1个元素A[0]~A[n-1]，令i从1到n-1枚举，进行n-1趟操作。假设某一趟时，序列A的前i-1个元素A[0]~A[i-1]已经有序，而范围[i,n-1]还未有序，那么该趟从范围[0,i-1]寻找某个位置j，使得将A[i]插入位置j之后 **（此时A[j]~A[i-1]会后移一位至A[j+1]~A[i]）**，范围[0,i]有序

### 三种排序代码
```cpp
#include <iostream>

using namespace std;

const int maxsize = 10;
int raw_seq[maxsize] = {3,4,1,2,8,9,10,7,11,5};
int sorted_seq[maxsize];

void bubble_sort()
{
    for(int i=0;i<maxsize;i++)
    {
        for(int j=i+1;j<maxsize;j++)
        {
            if(raw_seq[j]<raw_seq[i])
            {
                int tmp = raw_seq[i];
                raw_seq[i] = raw_seq[j];
                raw_seq[j] = tmp;
            }
        }
    }
}


void select_sort()
{
    for(int i=0;i<maxsize;i++)
    {
        int k = i;
        for(int j=i;j<maxsize;j++)
        {
            //注意比较时的细节，小于号右边为K
            if(raw_seq[j]<raw_seq[k])
            {
                k = j;
                //cout <<"k1 "<<k<<" ";
            }
        }
        //cout <<"k2 "<<k<<" ";
        int tmp = raw_seq[i];
        raw_seq[i] = raw_seq[k];
        raw_seq[k] = tmp;
    }
}


void insert_sort()
{
    for(int i=1;i<maxsize;i++)
    {
        int j = i;
        int tmp = raw_seq[i];
        while(j>0 && tmp<raw_seq[j-1])
        {
            raw_seq[j] = raw_seq[j-1];
            j--;
        }
        raw_seq[j] = tmp;
    }
}


int main()
{
    //bubble_sort();
    //select_sort();
    insert_sort();
    for(int i=0;i<maxsize;i++)
        cout << raw_seq[i]<<" ";
}
```
## 堆排序
- 堆排序是指使用堆结构对一个序列进行排序（考虑递增排序的情况）
- 考虑最大堆，堆顶元素最大，因此在建堆完毕后，堆排序的直观思路就是取出堆顶元素，然后将堆的最后一个元素替换至堆顶，再进行一次针对堆顶元素的向下调整
- 具体实现，为了节省空间，可以倒着遍历数组，假设当前访问到i号位，那么将堆顶元素与i号位的元素交换，接着在[1,i-1]范围内对堆顶元素进行一次向下调整即可
## TODO 快速排序
## TODO 归并排序
- 递归实现
- 非递归实现
## 排序题与sort函数的应用
### 相关结构体的定义
- 对于排序题
    - 一般会在题目中给出个体的许多信息，为了方便代码的书写，常常将它们存在一个结构体中，然后用结构体数组表示多个个体
- 定义结构体的小栗子
```cpp
struct student
{
    char name[10];
    char id[10];
    int scort;
    int r;
};
```
### cmp函数的编写
- 使用sort进行排序时，需要 **提供cmp函数实现排序规则**
    - 例子：对所有学生按分数高低排序，分数相同的按姓名的字典序从小到大排序
```cpp
bool cmp(student a,student b)
{
    if(a.score != b.score) 
        return a.score>b.score;
    else 
        return strcmp(a.name,b.name)<0;
}
```
- PAT1025---PAT Ranking
### 题1 ：PAT1025 PAT Ranking
* n个考场，每个考场有若干数量考生。现在给出各考场中考生的准考证号与分数，要求将所有考生按分数从高到低排序
* PAT1025 PAT Ranking ([https://pintia.cn/problem-sets/994805342720868352/problems/994805474338127872](https://pintia.cn/problem-sets/994805342720868352/problems/994805474338127872))
### 题1 所属类别
* 排序问题之结构体排序问题
### 题1 注意点
* c++中sort函数的应用----重点是根据题目排序规则编写 **cmp 函数**
* 若考生出现同分情况，排名的处理方式
### 基本算法步骤
* 学生信息结构体的定义及信息录入
* 应用c++内置的sort函数，并对应cmp函数的逻辑，对所有考生进行排序
* 按顺序计算总排名，并对应输出所有考生信息

## 散列
### 散列的定义与整数散列
- 用空间换时间
    - **直接将输入的数作为数组的下标来对这个数的性质进行统计**
- 散列是什么
    - 将元素通过一个函数转换为整数，使得该整数可以尽量唯一地代表这个元素
- 散列之后出现冲突怎么办
    - 线性探查法
    - 平方探查法
    - 链地址法
### 字符串hash初步
- TODO 对应算法题
## 递归
### 分治
- 注意点
    - 分治法分解出的子问题应当是相互独立，没有交叉的，如果存在两个子问题有相交部分，不应当使用分治法
### 递归
- 递归边界
- 递归式
- TODO 再次实现全排列和n皇后问题
### 贪心
#### 简单贪心
- 贪心法是求解一类最优化问题的方法，总是考虑当前状态下的局部最优（或较优）策略，来使全局结果达到最优（或较优）
- PAT B1020/1023
#### 题1 简单贪心---PAT B1020 月饼
* 给定所有种类月饼的库存量，总售价及市场的最大需求，计算可以获得的最大收益
* [https://pintia.cn/problem-sets/994805260223102976/problems/994805301562163200](https://pintia.cn/problem-sets/994805260223102976/problems/994805301562163200)
#### 题1 注意点
* 定义月饼的结构体，便于后续计算和排序
* 若采用 c/c++ ，注意售价和库存量采用 double 的数据类型
* c++ 中 sort函数的应用，对月饼按单价从高到低进行排序，便于后续贪心的选择
#### 题2 简单贪心---PAT B1023组最小数
* 给定数字 0-9 各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意 0 不能做首位）。例如：给定两个 0，两个 1，三个 5，一个 8，我们得到的最小的数就是 10015558。
* 输入：2 2 0 0 3 0 0 1 0 
* 输出：10015558
* [https://pintia.cn/problem-sets/994805260223102976/problems/994805298269634560](https://pintia.cn/problem-sets/994805260223102976/problems/994805298269634560)
#### 题2 注意点
* 注意输入的具体含义，对应的位置表示数字，输入的数字表示当前位置数字的个数
* 基本算法步骤
  * 首先找到除0之外的最小数，输出
  * 然后，依次输出对应位置的最小数，输出之后注意对应位置数字个数减一
#### 区间贪心
- 区间不相交问题
- 区间选点问题
### 二分
#### 二分查找
- 思考：如何在一个严格递增序列A中找出给定的数X
    - 二分查找是基于有序序列的查找算法
- 进一步的思考
    - 若递增序列A中的元素可能重复，如何对给定的预查询数据X，求出序列中第一个大于等于X元素的位置L，以及第一个大于X的元素的位置R
#### 二分法拓展
- 给定一个定义在[L,R]上的单调函数f(x)，求方程f(x)=0的根
- 装水问题
    - 侧面看去是半圆的储水装置，该半圆的半径为R，要求往里面装入高度为h的水，使其在侧面看去的面积S1与半圆面积S2的比例恰好为r。现给定R与r，求高度h
- 木棒切割问题
    - 给出N根木棒，长度均已知，现在希望通过切割它们来得到至少K段长度相等的木棒（长度必须是整数），问这些长度相等的木棒最长的长度L
- 任意多边形的外接圆最大半径
    - TODO
#### 快速幂
- 基于二分的思想，也成为二分幂
    - 快速幂的递归写法
    - 快速幂的迭代写法（非递归形式）
### two pointers
#### 什么是two pointers
- 给定一个递增的正整数序列和一个正整数M，求序列中的两个不同位置的数a和b，使得它们的和恰好为M
- 序列合并问题
    - 假设有两个递增序列A和B，要求将它们合并为一个递增序列C
### 归并排序
#### 2路归并排序
- 递归实现
- 非递归实现
### 快速排序法
### 其他高效技巧与算法
#### 打表
#### 活用递推
- PAT B1040/A1093
#### 题3: PAT A1093 有几个PAT
* 字符串 APPAPT 中包含了两个单词 PAT，其中第一个 PAT 是第 2 位(P)，第 4 位(A)，第 6 位(T)；第二个 PAT 是第 3 位(P)，第 4 位(A)，第 6 位(T)。现给定字符串，一共可以形成多少个 PAT？
* [https://pintia.cn/problem-sets/994805260223102976/problems/994805282389999616](https://pintia.cn/problem-sets/994805260223102976/problems/994805282389999616)
#### 题3 注意点
* 直接暴力搜索不行
* 运用一个数组 leftNumP 记录每一位左边P的个数（含当前位），然后以同样方法记录每一位右边T的个数，通过这两个变量，在**线性扫描该字符串时，即可得到对应的答案**
#### 随机选择算法
- TODO
### LC_1 两数之和
- 暴力搜索
- 哈希方法
### LC_2 两数相加
- 链表的操作
### LC_3 最长不重复子串
- 左右指针
- 哈希操作
### LC_4 寻找中位数
#### LC_4 注意点
- 时间复杂度要求`O(log(m+n))`
### LC_8 字符串转整数
- 字符串输入的特殊情况的处理
### LC_9 回文数
- 回文的定义
- 如何判定输入的整数是否是回文
    - 输入数字的后一半与输入数字的前一半是否相同
### LC_11 盛水最多的容器
- 双指针
- 最大面积的保留
- 左右指针何时进行处理
### LC_14 最长公共字符串
- c++中字符串方法的运用
- string.find()
    - string::npos --- 找不到
- string.substr(st,ed)
    - 返回对应的子串
### LC_21 合并两个有序链表
- 注意链表指针的一些处理
### LC_35 搜索插入位置
- 二分的应用
### LC_162 寻找峰值
- 二分的思路
    - 峰值存在于右侧
- 普通思路
### LC_174 地下城游戏
- 动态规划
    - 逆向思考，从迷宫的右下角当做初始状态考虑
    - 迷宫行列扩充`vector<vector<int>> dp(m+1, vector<int>(n+1,INT_MAX))`
### LC_209 长度最小的子数组
- 滑动窗口
- 双指针 
### LC_410 分割数组的最大值
- 二分法
- 左边界和右边界的取值
    - 二分的求和处理














